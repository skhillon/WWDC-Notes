---
contributors: skhillon
---

## Overview
This session builds directly on [Unsafe Swift](../10648). As a recap:

> Unsafe operations have **undefined** behavior on **some** input.

This talk covers Swift outside the normal "Safety Zone". Application programmers typically don't need to worry about this, but it's good to know.

Managing pointers safely means being aware of all the ways they can be *unsafe*. Most of this session is about pointer type safety, a source of undefined behavior in C that tends to be poorly understood.

Swift has APIs that provide the same low-level capabilities. This talk also covers how to avoid that kind of undefined behavior.

## Pointer Safety
Pointer safety can be thought of as a series of levels. Each level down, you take more responsibility for the correctness of your code. It's recommended that you write code at the highest safety level possible.

### Level 1/4: Safe Code
The highest level of safety is "Safe Code" like Collections, slices, and iterators. Swift has a robust type system that provides a lot of flexibility and performance which lets you avoid using pointers. **Not using pointers at all is a great strategy for code safety.**

### Level 2/4: Unsafe Code
An important capability of Swift is interoperability with unsafe languages. Swift provides `Unsafe...<T>` APIs for that interoperability. For example, `UnsafePointer<T>` lets you take responsibility for pointers without worrying about type safety.

### Level 3/4: Raw Memory
If you need to work with raw memory as a sequence of bytes, Swift provides the `UnsafeRawPointer`. Loading and storing values with raw memory gives you the responsibility for knowing the layout of types.

### Level 4/4: Mutable Type
At the deepest level, Swift provides a few APIs for binding memory to types. At this level, you take full responsibility away from Swift for managing the safety of pointer types.

## What is Safe Code?
**Safe code isn't necessarily correct code, but it does behave predictably.** In other words, if a programming error could lead to unpredictable behavior, the compiler catches it.

For errors that can't be caught at compile-time, runtime checks guarantee that the program crashes immediately with a diagnostic. It won't continue past an incorrect assumption.

Another way of defining safe code is: **Safe code is about error enforcement**. As long as you use Swift types and you address thread safety, then you know predictable behavior is fully enforced.

## Writing Unsafe Swift Code
Predictable behavior requires following the rules, so you take on extra responsibility. Testing still provides helpful diagnostics, but the level of diagnostics depends on the level of safety you've chosen.

Unsafe standard library APIs have assertions in debug builds that catch certain kinds of invalid input. It's also good practice to add your own precondition checks.

You can test with more runtime checks by adding sanitizers like the Address Sanitizer. These diagnostics can save a lot of time by pinpointing bugs, but they don't catch *all* undefined behavior.

When errors are not uncovered during testing, they can lead to unexpected runtime behavior. This could mean a hard-to-debug crash that occurs far from the source of the problem. Worse, it could mean that your program could do the wrong thing like corrupting user data. **A crash is bad, but corrupting or losing user data is worse.**

As safety decreases, undiagnosed errors are more difficult to find and understand. Sometimes they may not even show up until long after the bug was introduced.

## How can pointers be unsafe?
Swift is designed to be programmed without using pointers. Looking at why pointers are unsafe makes it clear why avoiding them is a good strategy.

Still, if you do need to access memory using low-level APIs, it's also useful to know how to manage different aspects of safety yourself.

### Pointer scope vs object lifetime
Before you can point to an object, the object needs a stable memory location. The stable storage that you point to has a limited lifetime, either because it goes out of scope or because the programmer deallocates that memory.

![][pointer_scope_object_lifetime]

Your pointer also has its own lifetime separate from the object's lifetime. When the pointer lifetime exceeds the object's lifetime, any attempt to access that object is undefined.

**This is the primary reason that pointers are unsafe.**

![][pointer_scope_object_lifetime_undefined]

### Object boundaries
Objects can be composed of a sequence of elements. Pointers are allowed to move to different memory addresses by adding offsets. This is an efficient way to address different elements, but adding or subtracting too large of an offset points to memory that doesn't belong to the same object. **This behavior is also undefined.**

![][object_boundary]

### Pointer types
Pointers have their own types distinct from the values in memory. How do we ensure those types are consistent? What happens if they aren't?

When we ask for a pointer to storage of type `Int16`, we get back a pointer also of type `Int16`. This makes sense. In fact, "it's pretty hard to get a pointer to the wrong type in Swift".

![][pointer_types1]

Now, let's say we manage to overwrite that memory with a different type like `Int32`. At this point, we have a pointer to the correct `Int32` type, but our `Int16` pointer still points to the same memory address. Accessing that old pointer is undefined behavior because the pointer type and the memory type are not the same.

![][pointer_types2]

#### How can undefined behavior be worse than a program crash? Why would pointer types cause that?
Let's look at some very unsafe code. While people tend not to write Swift code like this, you can end up with code like this if you're porting over old C code.

```swift
// Undefined behavior can lead to data loss!
// Maybe this type is imported from C.
struct Collage {
  var imageData: UnsafeMutablePointer<Image>?
  var imageCount: Int = 0
}

// C-style API expects a pointer-to-Int.
// This writes an image to memory and increases an image count.
func addImages(_ countPtr: UnsafeMutablePointer<UInt32>) -> UnsafeMutablePointer<Image> {
  let imageData = UnsafeMutablePointer<Image>.allocate(capacity: /* ... */)
  // ... other stuff ...
  imageData[cursor] = Image(/* ... */)
  countPtr.pointee += 1
  return imageData
}

func saveImages(_ imageData: UnsafeMutablePointer<Image>, _ count: Int)

var collage = Collage()
collage.imageData = withUnsafeMutablePointer(to: &collage.imageCount) {
  // Problem 1/2
  addImages(UnsafeMutableRawPointer($0).assumingMemoryBound(to: UInt32.self))
}

// Problem 2/2. You may see `imageCount == 0`.
saveImages(collage.imageData!, collage.imageCount)
```

##### Problem 1/2
We want to update the `imageCount` field in our `Collage` struct. However, there's a type mismatch. `Collage.imageCount` is of type `Int`, whereas `addImages` expects a pointer of type `UInt32`.

The correct thing to do here would be to create a new temporary variabe of type `UInt32` and take advantage of Swift's integer conversions. Instead, this complex line of code creates a pointer directly into the `Collage` struct.

##### Problem 2/2
Here, we try to save the image data. The problem is, at runtime, `collage.imageCount` could be 0 meaning that the program has silently lost all the images.

By giving the `imageCount` property an `Int` type and giving the pointer a `UInt32` type, we've signaled to the compiler that those values reside in different memory objects. The compiler does not see any updates to the `Int` object, so it could just reuse the initialization value of `0`.

![][pointer_data_loss]

**In practice, the compiler is forgiving and this small example will probably not go wrong,** but we can't predict what could happen. To the compiler, type information is a fact that assumptions are based on. If the compiler makes a bad assumption, that assumption could percolate through the compiler's pipeline and show up in surprising ways. A different version of the compiler could cause different program behavior on the same code.

#### Recap
Pointer type bugs:

- May cause unexpected behavior
- May remain hidden for a long time
- May be exposed at surprising times
  - By a safe-looking source change
  - By a compiler update

Managing pointer type safety was a problem long before Swift. Knowing how to use pointer types correctly in C requires deep knowledge of the language spec.

Pointer type rules for Swift and C:

- C has rules for "strict aliasing" and "type punning"
- Swift pointers can be used safely without knowing C rules
- Swift pointers safely interoperate with C because they are, at minimum, as safe as C pointers. In exchange, you need to take responsibility for object lifetime and object boundaries. You can learn more in the [Unsafe Swift](../10648) talk.

You do not need to take responsibility for type safety at the Unsafe Level (Level 2). `UnsafePointer<T>`'s generic parameter is enforced at compile time, so it is a type-safe API.

![][unsafepointer_typed]

Swift does **not** allow casting pointers like in C. This means type safety is guaranteed at compile time, and there is no extra runtime information for types.
![][swift_typed_pointers_strict]

## How is memory bound to a type? Where do typed pointers come from?

![][pointers_to_variables]

![][pointers_to_arrays]

You can also allocate memory directly without any initialized values. `assign` automatically deinitializes the previous value and assigns the new value:

![][direct_memory_allocation]

You generally won't have to worry about getting a pointer to the wrong type in Swift. One exception is composite types, where you can either get a pointer to the `struct` or the `Int` variable it contains. Both pointers are valid at the same time.

![][composite_types]

### Level 3: Raw Pointers
If you want to reinterprate bytes of memory as a different type (and circumvent Swift's type safety), you need to use `UnsafeRawPointer`. This lets you refer to a sequence of bytes without specifying the type of values they may represent. You take control over memory layout.

With raw pointers, you interpret values' types when you load them from memory. Consider a block of memory initialized to `Int64` using a typed pointer `UnsafeMutablePointer<Int64>`. It's always possible to cast from a typed pointer down to `UnsafeRawPointer`. Operations on that raw pointer only see the sequence of bytes in memory; the memory's bound type is irrelevant.

![][loading_bytes]

You can request any type from an `UnsafeRawPointer`. It does that by reading the required number of bytes and assembling them in the format required by the type.

For example, if you do:

```swift
let u = UnsafeRawPointer.load(as: UInt32.self)
```





[pointer_scope_object_lifetime]: ../../../images/notes/wwdc20/10167/pointer_scope_object_lifetime.png

[pointer_scope_object_lifetime_undefined]: ../../../images/notes/wwdc20/10167/pointer_scope_object_lifetime_undefined.png

[object_boundary]: ../../../images/notes/wwdc20/10167/object_boundary.png

[pointer_types1]: ../../../images/notes/wwdc20/10167/pointer_types1.png

[pointer_types2]: ../../../images/notes/wwdc20/10167/pointer_types2.png

[pointer_data_loss]: ../../../images/notes/wwdc20/10167/pointer_data_loss.png

[unsafepointer_typed]: ../../../images/notes/wwdc20/10167/unsafepointer_typed.png

[swift_typed_pointers_strict]: ../../../images/notes/wwdc20/10167/swift_typed_pointers_strict.png

[pointers_to_variables]: ../../../images/notes/wwdc20/10167/pointers_to_variables.png

[pointers_to_arrays]: ../../../images/notes/wwdc20/10167/pointers_to_arrays.png

[direct_memory_allocation]: ../../../images/notes/wwdc20/10167/direct_memory_allocation.png

[composite_types]: ../../../images/notes/wwdc20/10167/composite_types.png

[loading_bytes]: ../../../images/notes/wwdc20/10167/loading_bytes.png
